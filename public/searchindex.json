[{
  "section": "Blog",
  "slug": "/blog/golang/graceful-shutdown/",
  "title": "Graceful shutdown of server in Go",
  "description": "Graceful shutdown of server in Go",
  "date": "September 18, 2023",
  "image": null,
  "imageSM": null,
  "searchKeyword": "",
  "categories": "golang, server, shutdown, concurrency",
  "tags": "golang, concurrency, shutdown, server",
  "content":"Graceful shutdown Graceful shutdown refers to shutting down an application or service in a way that allows it to finish any ongoing tasks or transactions, clean up resources, and exit in an orderly and controlled manner. This is important to ensure that the application does not leave any unfinished work, corrupt data, or cause disruptions when it is terminated.\nFor example, we might be running a service in Kubernetes, and we are experiencing lower traffic so we would naturally scale down the number of pods. The load balancer will not redirect traffic to pods that are in a terminated state.\nNow our pods cannot just be terminated, since they might handle a long-running connection with a client(slow database query for example). Let\u0026rsquo;s see how we can gracefully terminate a server in golang.\nGolang std-lib provides this neat little package called errgroup Package errgroup provides synchronization, error propagation, and Context cancelation for groups of goroutines working on subtasks of a common task.\nThe context derived from errgroup got this nice property\nThe derived Context is canceled the first time a function passed to Go returns a non-nil error or the first time Wait returns, whichever occurs first.\nSo whenever one of the goroutines encountered an error this context will cancel.\nNow that sounds pretty neat, let\u0026rsquo;s take errgroup out on a little spin and create a server that gracefully exists whenever a termination signal(CTRL+C) comes in.\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) func main() { ctxWithCancel, cancel := context.WithCancel(context.Background()) defer cancel() g, ctx := errgroup.WithContext(ctxWithCancel) srv := \u0026amp;http.Server{Addr: fmt.Sprintf(\u0026#34;0.0.0.0:%d\u0026#34;, 8080)} g.Go(func() error { fmt.Println(\u0026#34;starting server\u0026#34;) if err := srv.ListenAndServe(); err != nil \u0026amp;\u0026amp; err != http.ErrServerClosed { return err } return nil }) g.Go(func() error { \u0026lt;-ctx.Done() shutDownCTX, cancel := context.WithTimeout(ctx, 1*time.Second) if err := srv.Shutdown(context.Background()); err != nil { fmt.Println(\u0026#34;encountered errors when shutting down\u0026#34;) } fmt.Println(\u0026#34;server shut down\u0026#34;) return nil }) g.Go(func() error { signals := make(chan os.Signal, 1) signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-signals fmt.Println(\u0026#34;terminating...\u0026#34;) cancel() return nil }) err := g.Wait() if err != nil { fmt.Println(err) } } Let\u0026rsquo;s run this to see what happens:\n\u0026gt; go main.go starting server terminating... \u0026lt;- CTRL+C to terminate server shut down Using errgroup we create a couple of goroutines:\ngoroutine for running the server goroutine for shutting down the server, it\u0026rsquo;s waiting for the context ctx to be done and then shuts down the server goroutine to check for any kind of termination signal from the OS "},{
  "section": "Blog",
  "slug": "/blog/golang/singleflight/",
  "title": "Singleflight",
  "description": "Singleflight in Golang",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/singleflight_hu0d51fe07e09032fb987a7b7c3c73247f_239700_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"167\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/singleflight_hu0d51fe07e09032fb987a7b7c3c73247f_239700_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/singleflight_hu0d51fe07e09032fb987a7b7c3c73247f_239700_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/singleflight_hu0d51fe07e09032fb987a7b7c3c73247f_239700_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "golang, concurrency",
  "tags": "golang, concurrency",
  "content":"Why Singleflight? Imagine you are running a service that calls a slow operation, let\u0026rsquo;s say it makes an expensive query to a database. Now this particular service is a popular one, before the first query even returned a result 10 more identical requests were made.\nWouldn\u0026rsquo;t it be nice if we didn\u0026rsquo;t have to call the database 10 times but instead return the data we get back from the first request to all other requests?\nWell, this is usually where caching comes in, but let\u0026rsquo;s be a little bit more experimental and give the package singleflight a swing.\nThis is how godoc describes singleflight:\nPackage singleflight provides a duplicate function call suppression mechanism.\nAlright sounds promising, the singleflight package in Go is a utility for managing duplicate function calls concurrently and efficiently. It helps ensure that a given function is executed only once even if multiple goroutines attempt to invoke it simultaneously.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/sync/singleflight\u0026#34; ) var ( counter = 0 group singleflight.Group ) type Response struct { Message string } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { result, err, _ := group.Do(\u0026#34;unique-key\u0026#34;, func() (interface{}, error) { val := incCounter() return \u0026amp;Response{Message: fmt.Sprintf(\u0026#34;called %d times\u0026#34;, val)}, nil }) if err != nil { fmt.Fprintf(w, \u0026#34;error %s\u0026#34;, err.Error()) } fmt.Fprintf(w, result.(*Response).Message) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } func incCounter() int { time.Sleep(10 * time.Second) counter = counter + 1 return counter } Let\u0026rsquo;s run this to see what happens:\n\u0026gt; go run server.go \u0026gt; curl localhost:8080/ \u0026lt;- New terminal window \u0026gt; called 1 times \u0026gt; curl localhost:8080/ \u0026lt;- New terminal window \u0026gt; called 1 times As we can see by this example the slow function incCounter is only invoked one time ðŸš€\ngroup.Do accepts a string that serves as an identifier or similar for a call, the third returned value indicated is the returned value shared.\nTip\nThe shared value is important if the returned value is a pointer then we might have to handle that to ensure we don\u0026rsquo;t run into nasty race conditions\n"},{
  "section": "Blog",
  "slug": "/blog/welcome/",
  "title": "Why blogging",
  "description": "Why blogging",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/thinking_hu7246add1908a87d764c931f28d10ba1c_174219_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"420\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/thinking_hu7246add1908a87d764c931f28d10ba1c_174219_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/thinking_hu7246add1908a87d764c931f28d10ba1c_174219_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/thinking_hu7246add1908a87d764c931f28d10ba1c_174219_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n",
  "searchKeyword": "",
  "categories": "Misc",
  "tags": "misc",
  "content":"Welcome to my blog! In this inaugural post, I want to share my motivations and aspirations behind this venture.\nLearning and Growth One of the primary reasons I started blogging is to document my personal growth as a software engineer. Every project, every bug, and every success has taught me something new. I believe that by sharing my experiences, I can help fellow developers who might be facing similar challenges or are just starting their journey. Whether it\u0026rsquo;s a tutorial on a new programming language or a deep dive into a complex algorithm.\nSolving Real-World Problems In the fast-paced tech industry, new challenges and solutions emerge daily. By documenting and sharing my experiences with tackling these challenges. I hope I can learn from documenting the challanged and hopefully help others.\nConclusion Feel free to reach out with any questions, comments, or topics you\u0026rsquo;d like to see covered. Let\u0026rsquo;s code on!\n"}]
